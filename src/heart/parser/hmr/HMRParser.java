//=========================================================================
//
//  This file was generated by Mouse 1.6.1 at 2014-11-03 11:26:04 GMT
//  from grammar
//    '/Users/msl/Documents/AGH/heart/heartdroid/hmr_parser_generator/HMRGr
//    ammar.peg'.
//
//=========================================================================

package heart.parser.hmr;

import heart.exceptions.ModelBuildingException;
import heart.exceptions.ParsingSyntaxException;
import heart.parser.hmr.runtime.Source;
import heart.xtt.XTTModel;

public class HMRParser extends heart.parser.hmr.runtime.ParserBase
{
  final HMRSemantics sem;

  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public HMRParser()
    {
      sem = new HMRSemantics();
      sem.rule = this;
      super.sem = sem;
    }

  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src) throws ParsingSyntaxException
    {
      super.init(src);
      sem.init();
      if (Start()) return true;
      return failure();
    }

  public XTTModel getModel() throws ModelBuildingException {
      return sem.getModel();
  }

  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public HMRSemantics semantics()
    { return sem; }

  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Start = Skip* HMRelement*+ EOF {throwSyntaxError} ;
  //=====================================================================
  private boolean Start() throws ParsingSyntaxException
    {
      begin("Start");
      while (Skip());
      while (!EOF())
        if (!HMRelement()) return reject();
      sem.throwSyntaxError();
      return accept();
    }

  //=====================================================================
  //  HMRelement = (HMRtype / HMRattr / HMRschm / HMRrule) / DEPelement
  //    ~{badElement} / BADelement ~{spottedEOF} ;
  //=====================================================================
  private boolean HMRelement()
  {
    begin("HMRelement");
    if (HMRelement_0()) return accept();
    if (DEPelement()) return accept();
    else sem.badElement();
    if (BADelement()) return accept();
    else sem.spottedEOF();
    return reject();
  }

  //-------------------------------------------------------------------
  //  HMRelement_0 = HMRtype / HMRattr / HMRschm / HMRrule
  //-------------------------------------------------------------------
  private boolean HMRelement_0()
  {
    begin("");
    if (HMRtype()) return acceptInner();
    if (HMRattr()) return acceptInner();
    if (HMRschm()) return acceptInner();
    if (HMRrule()) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  BADelement = (String / Number / ^["."])* Dot ;
  //=====================================================================
  private boolean BADelement()
  {
    begin("BADelement");
    while (BADelement_0());
    if (!Dot()) return reject();
    return accept();
  }

  //-------------------------------------------------------------------
  //  BADelement_0 = String / Number / ^["."]
  //-------------------------------------------------------------------
  private boolean BADelement_0()
  {
    begin("");
    if (String()) return acceptInner();
    if (Number()) return acceptInner();
    if (nextNotIn("\".\"")) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  DEPelement = ("xtraj" / "xtpgr" / "xatgr" / "xstat" / "xcall" /
  //    "xactn" / "xhalv") (String / Number / ^["."])* Dot
  //    {deprecatedElement} ;
  //=====================================================================
  private boolean DEPelement()
  {
    begin("DEPelement");
    if (!next("xtraj")
            && !next("xtpgr")
            && !next("xatgr")
            && !next("xstat")
            && !next("xcall")
            && !next("xactn")
            && !next("xhalv")
            ) return reject();
    while (BADelement_0());
    if (!Dot()) return reject();
    sem.deprecatedElement();
    return accept();
  }

  //=====================================================================
  //  HMRtype = "xtype" LSbracket HMRtypeElement (Comma HMRtypeElement)*
  //    RSbracket Dot {addType} <xtype definition> ;
  //=====================================================================
  private boolean HMRtype()
  {
    begin("HMRtype","xtype definition");
    if (!next("xtype")) return reject();
    if (!LSbracket()) return reject();
    if (!HMRtypeElement()) return reject();
    while (HMRtype_0());
    if (!RSbracket()) return reject();
    if (!Dot()) return reject();
    sem.addType();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRtype_0 = Comma HMRtypeElement
  //-------------------------------------------------------------------
  private boolean HMRtype_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!HMRtypeElement()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRtypeElement = HMRtypeName / HMRtypeBase / HMRtypeDomain /
  //    HMRtypeLength / HMRtypeOrdered / HMRtypeDesc / HMRtypeScale <type
  //    definition attribute> ;
  //=====================================================================
  private boolean HMRtypeElement()
  {
    begin("HMRtypeElement","type definition attribute");
    if (HMRtypeName()) return accept();
    if (HMRtypeBase()) return accept();
    if (HMRtypeDomain()) return accept();
    if (HMRtypeLength()) return accept();
    if (HMRtypeOrdered()) return accept();
    if (HMRtypeDesc()) return accept();
    if (HMRtypeScale()) return accept();
    return reject();
  }

  //=====================================================================
  //  HMRtypeName = "name" Colon String {buildTypeName} <type name> ;
  //=====================================================================
  private boolean HMRtypeName()
  {
    begin("HMRtypeName","type name");
    if (!next("name")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildTypeName();
    return accept();
  }

  //=====================================================================
  //  HMRtypeBase = "base" Colon ("numeric" / "symbolic") {buildTypeBase}
  //    <type base> ;
  //=====================================================================
  private boolean HMRtypeBase()
  {
    begin("HMRtypeBase","type base");
    if (!next("base")) return reject();
    if (!Colon()) return reject();
    if (!next("numeric")
            && !next("symbolic")
            ) return reject();
    sem.buildTypeBase();
    return accept();
  }

  //=====================================================================
  //  HMRtypeDomain = "domain" Colon (NumericValuesList /
  //    DomainSymbolsList) {buildTypeDomain} <type domain> ;
  //=====================================================================
  private boolean HMRtypeDomain()
  {
    begin("HMRtypeDomain","type domain");
    if (!next("domain")) return reject();
    if (!Colon()) return reject();
    if (!NumericValuesList()
            && !DomainSymbolsList()
            ) return reject();
    sem.buildTypeDomain();
    return accept();
  }

  //=====================================================================
  //  DomainSymbolsList = LSbracket DomainSymbol (Comma DomainSymbol)*
  //    RSbracket {buildValuesList} <symbols list> ;
  //=====================================================================
  private boolean DomainSymbolsList()
  {
    begin("DomainSymbolsList","symbols list");
    if (!LSbracket()) return reject();
    if (!DomainSymbol()) return reject();
    while (DomainSymbolsList_0());
    if (!RSbracket()) return reject();
    sem.buildValuesList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  DomainSymbolsList_0 = Comma DomainSymbol
  //-------------------------------------------------------------------
  private boolean DomainSymbolsList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!DomainSymbol()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  DomainSymbol = (OrderedStringValue / StringValue) {buildPassValue}
  //    <symbol> ;
  //=====================================================================
  private boolean DomainSymbol()
  {
    begin("DomainSymbol","symbol");
    if (!OrderedStringValue()
            && !StringValue()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  HMRtypeLength = "length" Colon UInteger {buildTypeLength} <type
  //    length> ;
  //=====================================================================
  private boolean HMRtypeLength()
  {
    begin("HMRtypeLength","type length");
    if (!next("length")) return reject();
    if (!Colon()) return reject();
    if (!UInteger()) return reject();
    sem.buildTypeLength();
    return accept();
  }

  //=====================================================================
  //  HMRtypeOrdered = "ordered" Colon ("yes" / "no") {buildTypeOrdered}
  //    <type order> ;
  //=====================================================================
  private boolean HMRtypeOrdered()
  {
    begin("HMRtypeOrdered","type order");
    if (!next("ordered")) return reject();
    if (!Colon()) return reject();
    if (!next("yes")
            && !next("no")
            ) return reject();
    sem.buildTypeOrdered();
    return accept();
  }

  //=====================================================================
  //  HMRtypeDesc = "desc" Colon String {buildTypeDescription} <type
  //    description> ;
  //=====================================================================
  private boolean HMRtypeDesc()
  {
    begin("HMRtypeDesc","type description");
    if (!next("desc")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildTypeDescription();
    return accept();
  }

  //=====================================================================
  //  HMRtypeScale = "scale" Colon UInteger <type scale (deprecated)> ;
  //=====================================================================
  private boolean HMRtypeScale()
  {
    begin("HMRtypeScale","type scale (deprecated)");
    if (!next("scale")) return reject();
    if (!Colon()) return reject();
    if (!UInteger()) return reject();
    return accept();
  }

  //=====================================================================
  //  HMRattr = "xattr" LSbracket HMRattrElement (Comma HMRattrElement)*
  //    RSbracket Dot {addAttribute} <xattr definition> ;
  //=====================================================================
  private boolean HMRattr()
  {
    begin("HMRattr","xattr definition");
    if (!next("xattr")) return reject();
    if (!LSbracket()) return reject();
    if (!HMRattrElement()) return reject();
    while (HMRattr_0());
    if (!RSbracket()) return reject();
    if (!Dot()) return reject();
    sem.addAttribute();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRattr_0 = Comma HMRattrElement
  //-------------------------------------------------------------------
  private boolean HMRattr_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!HMRattrElement()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRattrElement = HMRattrName / HMRattrClass / HMRattrType /
  //    HMRattrComm / HMRattrCallback / HMRattrAbbrev / HMRattrDesc
  //    <attribute element definition> ;
  //=====================================================================
  private boolean HMRattrElement()
  {
    begin("HMRattrElement","attribute element definition");
    if (HMRattrName()) return accept();
    if (HMRattrClass()) return accept();
    if (HMRattrType()) return accept();
    if (HMRattrComm()) return accept();
    if (HMRattrCallback()) return accept();
    if (HMRattrAbbrev()) return accept();
    if (HMRattrDesc()) return accept();
    return reject();
  }

  //=====================================================================
  //  HMRattrName = "name" Colon String {buildAttrName} <attribute name>
  //    ;
  //=====================================================================
  private boolean HMRattrName()
  {
    begin("HMRattrName","attribute name");
    if (!next("name")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildAttrName();
    return accept();
  }

  //=====================================================================
  //  HMRattrClass = "class" Colon ("simple" / "general")
  //    {buildAttrClass} <attribute class> ;
  //=====================================================================
  private boolean HMRattrClass()
  {
    begin("HMRattrClass","attribute class");
    if (!next("class")) return reject();
    if (!Colon()) return reject();
    if (!next("simple")
            && !next("general")
            ) return reject();
    sem.buildAttrClass();
    return accept();
  }

  //=====================================================================
  //  HMRattrType = "type" Colon String {buildAttrType} <attribute type>
  //    ;
  //=====================================================================
  private boolean HMRattrType()
  {
    begin("HMRattrType","attribute type");
    if (!next("type")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildAttrType();
    return accept();
  }

  //=====================================================================
  //  HMRattrComm = "comm" Colon ("out" / "inter" / "comm" / "in")
  //    {buildAttrComm} <attribute communication mode> ;
  //=====================================================================
  private boolean HMRattrComm()
  {
    begin("HMRattrComm","attribute communication mode");
    if (!next("comm")) return reject();
    if (!Colon()) return reject();
    if (!next("out")
            && !next("inter")
            && !next("comm")
            && !next("in")
            ) return reject();
    sem.buildAttrComm();
    return accept();
  }

  //=====================================================================
  //  HMRattrCallback = "callback" Colon Identifier {buildAttrCallback}
  //    <attribute callback name> ;
  //=====================================================================
  private boolean HMRattrCallback()
  {
    begin("HMRattrCallback","attribute callback name");
    if (!next("callback")) return reject();
    if (!Colon()) return reject();
    if (!Identifier()) return reject();
    sem.buildAttrCallback();
    return accept();
  }

  //=====================================================================
  //  HMRattrAbbrev = "abbrev" Colon String {buildAttrAbbreviation}
  //    <attribute abbreviation> ;
  //=====================================================================
  private boolean HMRattrAbbrev()
  {
    begin("HMRattrAbbrev","attribute abbreviation");
    if (!next("abbrev")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildAttrAbbreviation();
    return accept();
  }

  //=====================================================================
  //  HMRattrDesc = "desc" Colon String {buildAttrDescription} <attribute
  //    description> ;
  //=====================================================================
  private boolean HMRattrDesc()
  {
    begin("HMRattrDesc","attribute description");
    if (!next("desc")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildAttrDescription();
    return accept();
  }

  //=====================================================================
  //  HMRschm = "xschm" Skip* HMRschmName (Slash HMRschmDesc)? Colon
  //    HMRschmConditions EQarrow HMRschmDecisions Skip* Dot {addTable}
  //    <xschm definition> ;
  //=====================================================================
  private boolean HMRschm()
  {
    begin("HMRschm","xschm definition");
    if (!next("xschm")) return reject();
    while (Skip());
    if (!HMRschmName()) return reject();
    HMRschm_0();
    if (!Colon()) return reject();
    if (!HMRschmConditions()) return reject();
    if (!EQarrow()) return reject();
    if (!HMRschmDecisions()) return reject();
    while (Skip());
    if (!Dot()) return reject();
    sem.addTable();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRschm_0 = Slash HMRschmDesc
  //-------------------------------------------------------------------
  private boolean HMRschm_0()
  {
    begin("");
    if (!Slash()) return rejectInner();
    if (!HMRschmDesc()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRschmName = String {buildSchmName} <scheme name> ;
  //=====================================================================
  private boolean HMRschmName()
  {
    begin("HMRschmName","scheme name");
    if (!String()) return reject();
    sem.buildSchmName();
    return accept();
  }

  //=====================================================================
  //  HMRschmDesc = String {buildSchmDescription} <scheme description> ;
  //=====================================================================
  private boolean HMRschmDesc()
  {
    begin("HMRschmDesc","scheme description");
    if (!String()) return reject();
    sem.buildSchmDescription();
    return accept();
  }

  //=====================================================================
  //  HMRschmConditions = StringsList {buildSchmConditions} <scheme
  //    conditional attributes> ;
  //=====================================================================
  private boolean HMRschmConditions()
  {
    begin("HMRschmConditions","scheme conditional attributes");
    if (!StringsList()) return reject();
    sem.buildSchmConditions();
    return accept();
  }

  //=====================================================================
  //  HMRschmDecisions = StringsList {buildSchmDecisions} <scheme
  //    decisional attributes> ;
  //=====================================================================
  private boolean HMRschmDecisions()
  {
    begin("HMRschmDecisions","scheme decisional attributes");
    if (!StringsList()) return reject();
    sem.buildSchmDecisions();
    return accept();
  }

  //=====================================================================
  //  HMRrule = "xrule" Skip* HMRruleName Colon HMRruleConditionsList
  //    EQarrow HMRruleDecisionsList (STarrow HMRruleAction)? (Colon
  //    (HMRruleToken / HMRruleTokensList))? Dot {addRule} <xrule
  //    definition> ;
  //=====================================================================
  private boolean HMRrule()
  {
    begin("HMRrule","xrule definition");
    if (!next("xrule")) return reject();
    while (Skip());
    if (!HMRruleName()) return reject();
    if (!Colon()) return reject();
    if (!HMRruleConditionsList()) return reject();
    if (!EQarrow()) return reject();
    if (!HMRruleDecisionsList()) return reject();
    HMRrule_0();
    HMRrule_1();
    if (!Dot()) return reject();
    sem.addRule();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRrule_0 = STarrow HMRruleAction
  //-------------------------------------------------------------------
  private boolean HMRrule_0()
  {
    begin("");
    if (!STarrow()) return rejectInner();
    if (!HMRruleAction()) return rejectInner();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  HMRrule_1 = Colon (HMRruleToken / HMRruleTokensList)
  //-------------------------------------------------------------------
  private boolean HMRrule_1()
  {
    begin("");
    if (!Colon()) return rejectInner();
    if (!HMRruleToken()
            && !HMRruleTokensList()
            ) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRruleName = HMRruleId {buildRuleName} <rule name> ;
  //=====================================================================
  private boolean HMRruleName()
  {
    begin("HMRruleName","rule name");
    if (!HMRruleId()) return reject();
    sem.buildRuleName();
    return accept();
  }

  //=====================================================================
  //  HMRruleConditionsList = LSbracket HMRruleCondition (Comma
  //    HMRruleCondition)* RSbracket <rule conditions> ;
  //=====================================================================
  private boolean HMRruleConditionsList()
  {
    begin("HMRruleConditionsList","rule conditions");
    if (!LSbracket()) return reject();
    if (!HMRruleCondition()) return reject();
    while (HMRruleConditionsList_0());
    if (!RSbracket()) return reject();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRruleConditionsList_0 = Comma HMRruleCondition
  //-------------------------------------------------------------------
  private boolean HMRruleConditionsList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!HMRruleCondition()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRruleCondition = String HRCop {buildRuleCondition} <condition> ;
  //=====================================================================
  private boolean HMRruleCondition()
  {
    begin("HMRruleCondition","condition");
    if (!String()) return reject();
    if (!HRCop()) return reject();
    sem.buildRuleCondition();
    return accept();
  }

  //=====================================================================
  //  HRCop = Skip+ ("eq" / "noteq" / "lte" / "lt" / "gte" / "gt" /
  //    "subset" / "supset" / "sim" / "notsim" / "in" / "notin") Skip+
  //    HRDexpression {buildRuleConditionalStaticExpression} <comparison>
  //    ;
  //=====================================================================
  private boolean HRCop()
  {
    begin("HRCop","comparison");
    if (!Skip()) return reject();
    while (Skip());
    if (!next("eq")
            && !next("noteq")
            && !next("lte")
            && !next("lt")
            && !next("gte")
            && !next("gt")
            && !next("subset")
            && !next("supset")
            && !next("sim")
            && !next("notsim")
            && !next("in")
            && !next("notin")
            ) return reject();
    if (!Skip()) return reject();
    while (Skip());
    if (!HRDexpression()) return reject();
    sem.buildRuleConditionalStaticExpression();
    return accept();
  }

  //=====================================================================
  //  HMRruleDecisionsList = LSbracket HMRruleDecision (Comma
  //    HMRruleDecision)* RSbracket <rule decisions> ;
  //=====================================================================
  private boolean HMRruleDecisionsList()
  {
    begin("HMRruleDecisionsList","rule decisions");
    if (!LSbracket()) return reject();
    if (!HMRruleDecision()) return reject();
    while (HMRruleDecisionsList_0());
    if (!RSbracket()) return reject();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRruleDecisionsList_0 = Comma HMRruleDecision
  //-------------------------------------------------------------------
  private boolean HMRruleDecisionsList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!HMRruleDecision()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRruleDecision = String Skip+ "set" Skip+ HRDexpression
  //    {buildRuleDecision} <decision> ;
  //=====================================================================
  private boolean HMRruleDecision()
  {
    begin("HMRruleDecision","decision");
    if (!String()) return reject();
    if (!Skip()) return reject();
    while (Skip());
    if (!next("set")) return reject();
    if (!Skip()) return reject();
    while (Skip());
    if (!HRDexpression()) return reject();
    sem.buildRuleDecision();
    return accept();
  }

  //=====================================================================
  //  HRDexpression = HRDexpPrec3 {buildPassValue} <decisional
  //    expression> ;
  //=====================================================================
  private boolean HRDexpression()
  {
    begin("HRDexpression","decisional expression");
    if (!HRDexpPrec3()) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  HRDexpPrec0 = ValuesList {buildValueExpression} / NumberValue
  //    {buildValueExpression} / HRDopPrec0 {buildPassValue} / String
  //    {buildStringExpression} / Lbracket HRDexpression Rbracket
  //    {buildBrackettedExpression} ;
  //=====================================================================
  private boolean HRDexpPrec0()
  {
    begin("HRDexpPrec0");
    if (ValuesList())
    { sem.buildValueExpression(); return accept(); }
    if (NumberValue())
    { sem.buildValueExpression(); return accept(); }
    if (HRDopPrec0())
    { sem.buildPassValue(); return accept(); }
    if (String())
    { sem.buildStringExpression(); return accept(); }
    if (HRDexpPrec0_0())
    { sem.buildBrackettedExpression(); return accept(); }
    return reject();
  }

  //-------------------------------------------------------------------
  //  HRDexpPrec0_0 = Lbracket HRDexpression Rbracket
  //-------------------------------------------------------------------
  private boolean HRDexpPrec0_0()
  {
    begin("");
    if (!Lbracket()) return rejectInner();
    if (!HRDexpression()) return rejectInner();
    if (!Rbracket()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HRDexpPrec1 = HRDexpPrec0 (HRDopPrec1 HRDexpPrec0)*
  //    {buildAssociativeExpression} ;
  //=====================================================================
  private boolean HRDexpPrec1()
  {
    begin("HRDexpPrec1");
    if (!HRDexpPrec0()) return reject();
    while (HRDexpPrec1_0());
    sem.buildAssociativeExpression();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HRDexpPrec1_0 = HRDopPrec1 HRDexpPrec0
  //-------------------------------------------------------------------
  private boolean HRDexpPrec1_0()
  {
    begin("");
    if (!HRDopPrec1()) return rejectInner();
    if (!HRDexpPrec0()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HRDexpPrec2 = HRDexpPrec1 (HRDopPrec2 HRDexpPrec1)*
  //    {buildAssociativeExpression} ;
  //=====================================================================
  private boolean HRDexpPrec2()
  {
    begin("HRDexpPrec2");
    if (!HRDexpPrec1()) return reject();
    while (HRDexpPrec2_0());
    sem.buildAssociativeExpression();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HRDexpPrec2_0 = HRDopPrec2 HRDexpPrec1
  //-------------------------------------------------------------------
  private boolean HRDexpPrec2_0()
  {
    begin("");
    if (!HRDopPrec2()) return rejectInner();
    if (!HRDexpPrec1()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HRDexpPrec3 = HRDexpPrec2 (HRDopPrec3 HRDexpPrec2)*
  //    {buildAssociativeExpression} ;
  //=====================================================================
  private boolean HRDexpPrec3()
  {
    begin("HRDexpPrec3");
    if (!HRDexpPrec2()) return reject();
    while (HRDexpPrec3_0());
    sem.buildAssociativeExpression();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HRDexpPrec3_0 = HRDopPrec3 HRDexpPrec2
  //-------------------------------------------------------------------
  private boolean HRDexpPrec3_0()
  {
    begin("");
    if (!HRDopPrec3()) return rejectInner();
    if (!HRDexpPrec2()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HRDopPrec0 = (HRDopPrec0arg1 / HRDopPrec0arg2) {buildPassValue} ;
  //=====================================================================
  private boolean HRDopPrec0()
  {
    begin("HRDopPrec0");
    if (!HRDopPrec0arg1()
            && !HRDopPrec0arg2()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  HRDopPrec0arg1 = "dom" Lbracket String Rbracket
  //    {buildDomainOperator} / ("abs" / "cos" / "sin" / "tan" / "fac" /
  //    "log" / "setpower") Lbracket HRDexpression Rbracket
  //    {buildUnaryExpression} ;
  //=====================================================================
  private boolean HRDopPrec0arg1()
  {
    begin("HRDopPrec0arg1");
    if (HRDopPrec0arg1_0())
    { sem.buildDomainOperator(); return accept(); }
    if (HRDopPrec0arg1_1())
    { sem.buildUnaryExpression(); return accept(); }
    return reject();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec0arg1_0 = "dom" Lbracket String Rbracket
  //-------------------------------------------------------------------
  private boolean HRDopPrec0arg1_0()
  {
    begin("");
    if (!next("dom")) return rejectInner();
    if (!Lbracket()) return rejectInner();
    if (!String()) return rejectInner();
    if (!Rbracket()) return rejectInner();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec0arg1_1 = ("abs" / "cos" / "sin" / "tan" / "fac" / "log"
  //    / "setpower") Lbracket HRDexpression Rbracket
  //-------------------------------------------------------------------
  private boolean HRDopPrec0arg1_1()
  {
    begin("");
    if (!next("abs")
            && !next("cos")
            && !next("sin")
            && !next("tan")
            && !next("fac")
            && !next("log")
            && !next("setpower")
            ) return rejectInner();
    if (!Lbracket()) return rejectInner();
    if (!HRDexpression()) return rejectInner();
    if (!Rbracket()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HRDopPrec0arg2 = ("complement" / "except" / "intersec" / "union")
  //    Lbracket (ValuesList / HRDexpression) Comma (ValuesList /
  //    HRDexpression) Rbracket {buildBinaryExpression} ;
  //=====================================================================
  private boolean HRDopPrec0arg2()
  {
    begin("HRDopPrec0arg2");
    if (!next("complement")
            && !next("except")
            && !next("intersec")
            && !next("union")
            ) return reject();
    if (!Lbracket()) return reject();
    if (!ValuesList()
            && !HRDexpression()
            ) return reject();
    if (!Comma()) return reject();
    if (!ValuesList()
            && !HRDexpression()
            ) return reject();
    if (!Rbracket()) return reject();
    sem.buildBinaryExpression();
    return accept();
  }

  //=====================================================================
  //  HRDopPrec1 = Skip* "**" Skip* {buildOperator} <"**"> ;
  //=====================================================================
  private boolean HRDopPrec1()
  {
    begin("HRDopPrec1","\"**\"");
    while (Skip());
    if (!next("**")) return reject();
    while (Skip());
    sem.buildOperator();
    return accept();
  }

  //=====================================================================
  //  HRDopPrec2 = (Skip* "*" Skip* / Skip* "/" Skip* / Skip* "mod"
  //    Skip*) {buildOperator} <"*" or "/" or "mod"> ;
  //=====================================================================
  private boolean HRDopPrec2()
  {
    begin("HRDopPrec2","\"*\" or \"/\" or \"mod\"");
    if (!HRDopPrec2_0()
            && !HRDopPrec2_1()
            && !HRDopPrec2_2()
            ) return reject();
    sem.buildOperator();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec2_0 = Skip* "*" Skip*
  //-------------------------------------------------------------------
  private boolean HRDopPrec2_0()
  {
    begin("");
    while (Skip());
    if (!next('*')) return rejectInner();
    while (Skip());
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec2_1 = Skip* "/" Skip*
  //-------------------------------------------------------------------
  private boolean HRDopPrec2_1()
  {
    begin("");
    while (Skip());
    if (!next('/')) return rejectInner();
    while (Skip());
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec2_2 = Skip* "mod" Skip*
  //-------------------------------------------------------------------
  private boolean HRDopPrec2_2()
  {
    begin("");
    while (Skip());
    if (!next("mod")) return rejectInner();
    while (Skip());
    return acceptInner();
  }

  //=====================================================================
  //  HRDopPrec3 = (Skip* "+" Skip* / Skip* "-" Skip*) {buildOperator}
  //    <"+" or "-"> ;
  //=====================================================================
  private boolean HRDopPrec3()
  {
    begin("HRDopPrec3","\"+\" or \"-\"");
    if (!HRDopPrec3_0()
            && !HRDopPrec3_1()
            ) return reject();
    sem.buildOperator();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec3_0 = Skip* "+" Skip*
  //-------------------------------------------------------------------
  private boolean HRDopPrec3_0()
  {
    begin("");
    while (Skip());
    if (!next('+')) return rejectInner();
    while (Skip());
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec3_1 = Skip* "-" Skip*
  //-------------------------------------------------------------------
  private boolean HRDopPrec3_1()
  {
    begin("");
    while (Skip());
    if (!next('-')) return rejectInner();
    while (Skip());
    return acceptInner();
  }

  //=====================================================================
  //  HMRruleAction = IdentifiersList {buildRuleActions} <rule action> ;
  //=====================================================================
  private boolean HMRruleAction()
  {
    begin("HMRruleAction","rule action");
    if (!IdentifiersList()) return reject();
    sem.buildRuleActions();
    return accept();
  }

  //=====================================================================
  //  HMRruleTokensList = LSbracket HMRruleToken (Comma HMRruleToken)*
  //    RSbracket <list of rule links> ;
  //=====================================================================
  private boolean HMRruleTokensList()
  {
    begin("HMRruleTokensList","list of rule links");
    if (!LSbracket()) return reject();
    if (!HMRruleToken()) return reject();
    while (HMRruleTokensList_0());
    if (!RSbracket()) return reject();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRruleTokensList_0 = Comma HMRruleToken
  //-------------------------------------------------------------------
  private boolean HMRruleTokensList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!HMRruleToken()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRruleToken = (HMRruleId / HMRRuleSchemeId) {buildRuleLink} <rule
  //    link> ;
  //=====================================================================
  private boolean HMRruleToken()
  {
    begin("HMRruleToken","rule link");
    if (!HMRruleId()
            && !HMRRuleSchemeId()
            ) return reject();
    sem.buildRuleLink();
    return accept();
  }

  //=====================================================================
  //  HMRruleId = String "/" HMRruleIndex {buildRuleId} <rule id> ;
  //=====================================================================
  private boolean HMRruleId()
  {
    begin("HMRruleId","rule id");
    if (!String()) return reject();
    if (!next('/')) return reject();
    if (!HMRruleIndex()) return reject();
    sem.buildRuleId();
    return accept();
  }

  //=====================================================================
  //  HMRruleIndex = Integer {buildRuleIndex} <rule index> ;
  //=====================================================================
  private boolean HMRruleIndex()
  {
    begin("HMRruleIndex","rule index");
    if (!Integer()) return reject();
    sem.buildRuleIndex();
    return accept();
  }

  //=====================================================================
  //  HMRRuleSchemeId = String {buildRuleSchemeId} <scheme id> ;
  //=====================================================================
  private boolean HMRRuleSchemeId()
  {
    begin("HMRRuleSchemeId","scheme id");
    if (!String()) return reject();
    sem.buildRuleSchemeId();
    return accept();
  }

  //=====================================================================
  //  Colon = Skip* ":" Skip* <":"> ;
  //=====================================================================
  private boolean Colon()
  {
    begin("Colon","\":\"");
    while (Skip());
    if (!next(':')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Dot = Skip* "." Skip* <"."> ;
  //=====================================================================
  private boolean Dot()
  {
    begin("Dot","\".\"");
    while (Skip());
    if (!next('.')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Comma = Skip* "," Skip* <","> ;
  //=====================================================================
  private boolean Comma()
  {
    begin("Comma","\",\"");
    while (Skip());
    if (!next(',')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  LSbracket = Skip* "[" Skip* <"["> ;
  //=====================================================================
  private boolean LSbracket()
  {
    begin("LSbracket","\"[\"");
    while (Skip());
    if (!next('[')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  RSbracket = Skip* "]" Skip* <"]"> ;
  //=====================================================================
  private boolean RSbracket()
  {
    begin("RSbracket","\"]\"");
    while (Skip());
    if (!next(']')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  RangeOp = Skip* "to" Skip* <"to"> ;
  //=====================================================================
  private boolean RangeOp()
  {
    begin("RangeOp","\"to\"");
    while (Skip());
    if (!next("to")) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  EQarrow = Skip* "==>" Skip* <"==>"> ;
  //=====================================================================
  private boolean EQarrow()
  {
    begin("EQarrow","\"==>\"");
    while (Skip());
    if (!next("==>")) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  STarrow = Skip* "**>" Skip* <"**>"> ;
  //=====================================================================
  private boolean STarrow()
  {
    begin("STarrow","\"**>\"");
    while (Skip());
    if (!next("**>")) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Slash = Skip* "/" Skip* <"/""> ;
  //=====================================================================
  private boolean Slash()
  {
    begin("Slash","\"/\"\"");
    while (Skip());
    if (!next('/')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Lbracket = Skip* "(" Skip* <"("> ;
  //=====================================================================
  private boolean Lbracket()
  {
    begin("Lbracket","\"(\"");
    while (Skip());
    if (!next('(')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Rbracket = Skip* ")" Skip* <")"> ;
  //=====================================================================
  private boolean Rbracket()
  {
    begin("Rbracket","\")\"");
    while (Skip());
    if (!next(')')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  ValuesList = (NumericValuesList / SymbolicValuesList)
  //    {buildPassValue} <list of values> ;
  //=====================================================================
  private boolean ValuesList()
  {
    begin("ValuesList","list of values");
    if (!NumericValuesList()
            && !SymbolicValuesList()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  Value = (NumberValue / StringValue) {buildPassValue} <value> ;
  //=====================================================================
  private boolean Value()
  {
    begin("Value","value");
    if (!NumberValue()
            && !StringValue()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  NumericValuesList = LSbracket NumericValue (Comma NumericValue)*
  //    RSbracket {buildValuesList} <list of numeric values> ;
  //=====================================================================
  private boolean NumericValuesList()
  {
    begin("NumericValuesList","list of numeric values");
    if (!LSbracket()) return reject();
    if (!NumericValue()) return reject();
    while (NumericValuesList_0());
    if (!RSbracket()) return reject();
    sem.buildValuesList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  NumericValuesList_0 = Comma NumericValue
  //-------------------------------------------------------------------
  private boolean NumericValuesList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!NumericValue()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  NumericValue = (NumberValuesRange / NumberValue) {buildPassValue}
  //    <numeric value> ;
  //=====================================================================
  private boolean NumericValue()
  {
    begin("NumericValue","numeric value");
    if (!NumberValuesRange()
            && !NumberValue()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  NumberValuesRange = NumberValue RangeOp NumberValue
  //    {buildValuesRange} <range of numbers> ;
  //=====================================================================
  private boolean NumberValuesRange()
  {
    begin("NumberValuesRange","range of numbers");
    if (!NumberValue()) return reject();
    if (!RangeOp()) return reject();
    if (!NumberValue()) return reject();
    sem.buildValuesRange();
    return accept();
  }

  //=====================================================================
  //  SymbolicValuesList = LSbracket SymbolicValue (Comma SymbolicValue)*
  //    RSbracket {buildValuesList} <list of symbolic values> ;
  //=====================================================================
  private boolean SymbolicValuesList()
  {
    begin("SymbolicValuesList","list of symbolic values");
    if (!LSbracket()) return reject();
    if (!SymbolicValue()) return reject();
    while (SymbolicValuesList_0());
    if (!RSbracket()) return reject();
    sem.buildValuesList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  SymbolicValuesList_0 = Comma SymbolicValue
  //-------------------------------------------------------------------
  private boolean SymbolicValuesList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!SymbolicValue()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  SymbolicValue = (StringValuesRange / StringValue) {buildPassValue}
  //    <symbolic value> ;
  //=====================================================================
  private boolean SymbolicValue()
  {
    begin("SymbolicValue","symbolic value");
    if (!StringValuesRange()
            && !StringValue()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  StringValuesRange = StringValue RangeOp StringValue
  //    {buildValuesRange} <range of strings> ;
  //=====================================================================
  private boolean StringValuesRange()
  {
    begin("StringValuesRange","range of strings");
    if (!StringValue()) return reject();
    if (!RangeOp()) return reject();
    if (!StringValue()) return reject();
    sem.buildValuesRange();
    return accept();
  }

  //=====================================================================
  //  StringsList = LSbracket String (Comma String)* RSbracket
  //    {buildList} <list of string> ;
  //=====================================================================
  private boolean StringsList()
  {
    begin("StringsList","list of string");
    if (!LSbracket()) return reject();
    if (!String()) return reject();
    while (StringsList_0());
    if (!RSbracket()) return reject();
    sem.buildList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  StringsList_0 = Comma String
  //-------------------------------------------------------------------
  private boolean StringsList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!String()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  IdentifiersList = LSbracket Identifier (Comma Identifier)*
  //    RSbracket {buildList} <list of foreign identifiers> ;
  //=====================================================================
  private boolean IdentifiersList()
  {
    begin("IdentifiersList","list of foreign identifiers");
    if (!LSbracket()) return reject();
    if (!Identifier()) return reject();
    while (IdentifiersList_0());
    if (!RSbracket()) return reject();
    sem.buildList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  IdentifiersList_0 = Comma Identifier
  //-------------------------------------------------------------------
  private boolean IdentifiersList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!Identifier()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  OrderedStringValue = String Slash UInteger
  //    {buildOrderedStringValue} <ordered string> ;
  //=====================================================================
  private boolean OrderedStringValue()
  {
    begin("OrderedStringValue","ordered string");
    if (!String()) return reject();
    if (!Slash()) return reject();
    if (!UInteger()) return reject();
    sem.buildOrderedStringValue();
    return accept();
  }

  //=====================================================================
  //  StringValue = String {buildStringValue} <string> ;
  //=====================================================================
  private boolean StringValue()
  {
    begin("StringValue","string");
    if (!String()) return reject();
    sem.buildStringValue();
    return accept();
  }

  //=====================================================================
  //  String = (QuotedString / NormalString) {buildPassValue} <string> ;
  //=====================================================================
  private boolean String()
  {
    begin("String","string");
    if (!QuotedString()
            && !NormalString()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  QuotedString = "'" ^["'"]* "'" {buildQuotedString} <quoted string>
  //    ;
  //=====================================================================
  private boolean QuotedString()
  {
    begin("QuotedString","quoted string");
    if (!next('\'')) return reject();
    while (nextNotIn("\"'\""));
    if (!next('\'')) return reject();
    sem.buildQuotedString();
    return accept();
  }

  //=====================================================================
  //  NormalString = [a-z] ([a-z] / [A-Z] / [0-9] / "_")*
  //    {buildNormalString} <unquoted string> ;
  //=====================================================================
  private boolean NormalString()
  {
    begin("NormalString","unquoted string");
    if (!nextIn('a','z')) return reject();
    while (NormalString_0());
    sem.buildNormalString();
    return accept();
  }

  //-------------------------------------------------------------------
  //  NormalString_0 = [a-z] / [A-Z] / [0-9] / "_"
  //-------------------------------------------------------------------
  private boolean NormalString_0()
  {
    begin("");
    if (nextIn('a','z')) return acceptInner();
    if (nextIn('A','Z')) return acceptInner();
    if (nextIn('0','9')) return acceptInner();
    if (next('_')) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  Identifier = NormalString {buildPassValue} / "'" ([a-z] / [A-Z] /
  //    "_") ([a-z] / [A-Z] / "_" / [0-9])* "'" {buildQuotedString}
  //    <foreign identifier> ;
  //=====================================================================
  private boolean Identifier()
  {
    begin("Identifier","foreign identifier");
    if (NormalString())
    { sem.buildPassValue(); return accept(); }
    if (Identifier_0())
    { sem.buildQuotedString(); return accept(); }
    return reject();
  }

  //-------------------------------------------------------------------
  //  Identifier_0 = "'" ([a-z] / [A-Z] / "_") ([a-z] / [A-Z] / "_" /
  //    [0-9])* "'"
  //-------------------------------------------------------------------
  private boolean Identifier_0()
  {
    begin("");
    if (!next('\'')) return rejectInner();
    if (!nextIn('a','z')
            && !nextIn('A','Z')
            && !next('_')
            ) return rejectInner();
    while (Identifier_1());
    if (!next('\'')) return rejectInner();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  Identifier_1 = [a-z] / [A-Z] / "_" / [0-9]
  //-------------------------------------------------------------------
  private boolean Identifier_1()
  {
    begin("");
    if (nextIn('a','z')) return acceptInner();
    if (nextIn('A','Z')) return acceptInner();
    if (next('_')) return acceptInner();
    if (nextIn('0','9')) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  NumberValue = (FloatValue / IntegerValue) {buildPassValue} <number>
  //    ;
  //=====================================================================
  private boolean NumberValue()
  {
    begin("NumberValue","number");
    if (!FloatValue()
            && !IntegerValue()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  Number = (Float / Integer) {buildPassValue} <number> ;
  //=====================================================================
  private boolean Number()
  {
    begin("Number","number");
    if (!Float()
            && !Integer()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  FloatValue = Float {buildNumberFloatValue} <float> ;
  //=====================================================================
  private boolean FloatValue()
  {
    begin("FloatValue","float");
    if (!Float()) return reject();
    sem.buildNumberFloatValue();
    return accept();
  }

  //=====================================================================
  //  Float = ("-" White*)? UFloat {buildSignedFloat} <float> ;
  //=====================================================================
  private boolean Float()
  {
    begin("Float","float");
    Float_0();
    if (!UFloat()) return reject();
    sem.buildSignedFloat();
    return accept();
  }

  //-------------------------------------------------------------------
  //  Float_0 = "-" White*
  //-------------------------------------------------------------------
  private boolean Float_0()
  {
    begin("");
    if (!next('-')) return rejectInner();
    while (White());
    return acceptInner();
  }

  //=====================================================================
  //  UFloat = [0-9]+ "." [0-9]+ {buildUnsignedFloat} <unsigned float> ;
  //=====================================================================
  private boolean UFloat()
  {
    begin("UFloat","unsigned float");
    if (!nextIn('0','9')) return reject();
    while (nextIn('0','9'));
    if (!next('.')) return reject();
    if (!nextIn('0','9')) return reject();
    while (nextIn('0','9'));
    sem.buildUnsignedFloat();
    return accept();
  }

  //=====================================================================
  //  IntegerValue = Integer {buildNumberIntValue} <integer> ;
  //=====================================================================
  private boolean IntegerValue()
  {
    begin("IntegerValue","integer");
    if (!Integer()) return reject();
    sem.buildNumberIntValue();
    return accept();
  }

  //=====================================================================
  //  Integer = ("-" White*)? UInteger {buildSignedInteger} <integer> ;
  //=====================================================================
  private boolean Integer()
  {
    begin("Integer","integer");
    Float_0();
    if (!UInteger()) return reject();
    sem.buildSignedInteger();
    return accept();
  }

  //=====================================================================
  //  UInteger = [0-9]+ {buildUnsignedInteger} <unsigned integer> ;
  //=====================================================================
  private boolean UInteger()
  {
    begin("UInteger","unsigned integer");
    if (!nextIn('0','9')) return reject();
    while (nextIn('0','9'));
    sem.buildUnsignedInteger();
    return accept();
  }

  //=====================================================================
  //  Skip = (Comment / Clause / White) {passSkip} <skippable element> ;
  //=====================================================================
  private boolean Skip()
  {
    begin("Skip","skippable element");
    if (!Comment()
            && !Clause()
            && !White()
            ) return reject();
    sem.passSkip();
    return accept();
  }

  //=====================================================================
  //  Comment = "%" _*+ EOL / CommentStart _*+ CommentEnd <comment> ;
  //=====================================================================
  private boolean Comment()
  {
    begin("Comment","comment");
    if (Comment_0()) return accept();
    if (Comment_1()) return accept();
    return reject();
  }

  //-------------------------------------------------------------------
  //  Comment_0 = "%" _*+ EOL
  //-------------------------------------------------------------------
  private boolean Comment_0()
  {
    begin("");
    if (!next('%')) return rejectInner();
    while (!EOL())
      if (!next()) return rejectInner();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  Comment_1 = CommentStart _*+ CommentEnd
  //-------------------------------------------------------------------
  private boolean Comment_1()
  {
    begin("");
    if (!CommentStart()) return rejectInner();
    while (!CommentEnd())
      if (!next()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  CommentStart = "/*" ;
  //=====================================================================
  private boolean CommentStart()
  {
    begin("CommentStart");
    if (!next("/*")) return reject();
    return accept();
  }

  //=====================================================================
  //  CommentEnd = "*/" ;
  //=====================================================================
  private boolean CommentEnd()
  {
    begin("CommentEnd");
    if (!next("*/")) return reject();
    return accept();
  }

  //=====================================================================
  //  Clause = ":-" (String / ^["."])* "." <prolog clause> ;
  //=====================================================================
  private boolean Clause()
  {
    begin("Clause","prolog clause");
    if (!next(":-")) return reject();
    while (Clause_0());
    if (!next('.')) return reject();
    return accept();
  }

  //-------------------------------------------------------------------
  //  Clause_0 = String / ^["."]
  //-------------------------------------------------------------------
  private boolean Clause_0()
  {
    begin("");
    if (String()) return acceptInner();
    if (nextNotIn("\".\"")) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  White = [ \t\r\n] <whitespace character> ;
  //=====================================================================
  private boolean White()
  {
    begin("White","whitespace character");
    if (!nextIn(" \t\r\n")) return reject();
    return accept();
  }

  //=====================================================================
  //  EOL = [\n\r]+ / EOF <end of line> ;
  //=====================================================================
  private boolean EOL()
  {
    begin("EOL","end of line");
    if (EOL_0()) return accept();
    if (EOF()) return accept();
    return reject();
  }

  //-------------------------------------------------------------------
  //  EOL_0 = [\n\r]+
  //-------------------------------------------------------------------
  private boolean EOL_0()
  {
    begin("");
    if (!nextIn("\n\r")) return rejectInner();
    while (nextIn("\n\r"));
    return acceptInner();
  }

  //=====================================================================
  //  EOF = !_ <end of file> ;
  //=====================================================================
  private boolean EOF()
  {
    begin("EOF","end of file");
    if (!aheadNot()) return reject();
    return accept();
  }

}
